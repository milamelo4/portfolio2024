<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta name="description" content="Notes Week 02">
    <title>Week 02</title>
    <link rel="stylesheet" href="../style/style.css">
    <link rel="shortcut icon" href="../favicon-32x32.png" type="image/x-icon">
</head>
<body>
    <main>
        <h1>My Notes for week 02:</h1>
        <h2>Readings</h2>
        <ul>
            <li>Modifying the document</li>
            <li>LocalStorage, sessionStorage</li>
            <li>Modules: Import and Export.</li>
        </ul>
        <h3>Modifying the document:</h3>
        <p>Creating elements on the fly. To create DOM node there are two methods:</p>
        <code>
            let div = document.createElement('div') -> Creates a tag<br>
            let textNode = document.createTextNode('Here I am') -> Appends the text to the tag.<br>
            div.className = 'alert' -> Adds a class for styling.
        </code>
       <h3>Nodes in the DOM tree can have different types, including:</h3>

        <p><strong>Element nodes:</strong> Represent HTML elements like &lt;div&gt;, &lt;p&gt;, &lt;h1&gt;, etc. An HTML tag.</p>
        <p><STRONG>Text nodes:</STRONG> Contain textual content within an element.</p>
        <P><STRONG>Attribute nodes:</STRONG> Represent attributes of an element, such as class, id, src, etc.</P>
        <P><STRONG>Document nodes:</STRONG> Represent the entire document itself.</p>
        
        <h3>Here are more insertion methods, they specify different places where to insert: THIS IS NEW TO ME:</h3>

        <ul>
            <li>node.append(...nodes or strings) -> append nodes or strings at the end of node. Just like a list.</li>
            <li>node.prepend(...nodes or strings) -> insert nodes or strings at the beginning of node</li>
            <li>node.before(...nodes or strings) -> insert nodes or strings before node,</li>
            <li>node.after(...nodes or strings) -> insert nodes or strings after node,</li>
            <li>node.replaceWith(...nodes or strings) -> replaces node with the given nodes or strings.</li>
        </ul>
        <ol id="ol">
            <li>0</li>
            <li>1</li>
            <li>2</li>
        </ol>
       <p><i>Check notes in Js for more info.</i></p>
       <h3>insertAdjacentHTML/Text/Element</h3>
       <p>elem.insertAdjacentHTML(where, html)</p>
       <p>The first parameter is a code word, specifying where to insert relative to elem. Must be one of the following:</p>

        <ul>
            <li>"beforebegin" -> insert html immediately before elem,</li>
            <li>"afterbegin" -> insert html into elem, at the beginning,</li>
            <li>"beforeend" -> insert html into elem, at the end,</li>
            <li>"afterend" -> insert html immediately after elem.</li>
        </ul>
        <aside id="aside"></aside>
        <p>So here's an alternative variant of showing a message:</p>

        <code>
            document.body.insertAdjacentHTML("afterbegin", `&lt;div class="alert"&gt;
                <strong>Hi there!</strong> You've read an important message.
            &lt;/div&gt;`);
        </code>
        <p>All insertion methods automatically remove the node from the old place:</p>
        <p>Original:</p> </p>&lt;div id="first"&gt;First&lt;/div&gt; <br>
        &lt;div id="second"&gt;Second&gt/div&gt;<p> 
        <p>Swapping with JS:</p>
        <div id="first">First</div>
        <div id="second">Second</div>

        <h3>Cloning nodes: cloneNode</h3>
        <p>Sometimes when we have a big element, that may be faster and simpler.</p>
        <div class="alert3" id="div3"><strong>Hi there!</strong> I am the cloning alert.</div>
        <ul>
            <li>The call elem.cloneNode(true) creates a “deep” clone of the element -> with all attributes and subelements.</li>
            <li>If we call elem.cloneNode(false), then the clone is made without child elements.</li>
        </ul>

        <h3>Document Fragment:</h3>
        <p>DocumentFragment is a special DOM node that serves as a wrapper to pass around lists of nodes.
        We can append other nodes to it, but when we insert it somewhere, then its content is inserted instead.</p>
        <ul id="ul2"></ul>
        <p>I guess this didn't make much sense to me because we are using list, and its normal to append the li's to the ul. However, this would be good with a div tag, when you need a wrapper.</p>
        <p>DocumentFragment is rarely used explicitly. Why append to a special kind of node, if we can return an array of nodes instead? Rewritten example:</p>
        <p>See JS and console for code example.</p>
        <ul id="ul4"></ul>
        <h3 style="font-size: 25px;">Summary</h3>
        <p>Methods to create new nodes:</p>
        <ul>
            <li>document.createElement(tag) -> creates an element with the given tag,</li>
            <li>document.createTextNode(value) -> creates a text node (rarely used),</li>
            <li>elem.cloneNode(deep) -> clones the element, if deep==true then with all descendants.</li>
        </ul>

        <p>Insertion and removal:</p>
        <li>node.append(...nodes or strings) -> insert into node, at the end,</li>
        <li>node.prepend(...nodes or strings) -> insert into node, at the beginning,</li>
        <li>node.before(...nodes or strings) ->- insert right before node,</li>
        <li>node.after(...nodes or strings) ->- insert right after node,</li>
        <li>node.replaceWith(...nodes or strings) ->- replace node.</li>
        <li>node.remove() ->- remove the node.</li>

        <p>There are also “old school” methods:</p>
        <ul>
            <li>parent.appendChild(node)</li>
            <li>parent.insertBefore(node, nextSibling)</li>
            <li>parent.removeChild(node)</li>
            <li>parent.replaceChild(newElem, node)</li>
        </ul>

        <p>Given some HTML in html, elem.insertAdjacentHTML(where, html) inserts it depending on the value of where:</p>

        <ul>
            <li>"beforebegin" -> insert html right before elem,</li>
            <li>"afterbegin" -> insert html into elem, at the beginning,</li>
            <li>"beforeend" -> insert html into elem, at the end,</li>
            <li>"afterend" -> insert html right after elem.</li>
        </ul>
        
        <h2>LocalStorage | sessionStorage</h2>
        <ul>
            <li>Web storage objects localStorage and sessionStorage allow to save key/value pairs in the browser.
            The data survives a page refresh (for sessionStorage) and even a full browser restart (for localStorage).</li>
            <li>Unlike cookies, web storage objects are not sent to server with each request. Because of that, we can store much more.</li>
            <li>The storage is bound to the origin (domain/protocol/port triplet). </li>
        </ul>
        <p>Both storage objects provide the same methods and properties:</p>

        <ul>
            <li>setItem(key, value) -> store key/value pair.</li>
            <li>getItem(key) -> get the value by key.</li>
            <li>removeItem(key) -> remove the key with its value.</li>
            <li>clear() -> delete everything.</li>
            <li>key(index) -> get the key on a given position.</li>
            <li>length -> the number of stored items.</li>
        </ul>
        <p><strong>LocalStorage</strong></p> 
        <p>Looping over keys:</p>
        <p>Unfortunately, storage objects are not iterable
        just get the “own” keys with Object.keys and then loop over them if needed:</p>

        <pre>
        let keys = Object.keys(localStorage);
        for(let key of keys) {
        alert(`${key}: ${localStorage.getItem(key)}`);
        }
        </pre>
        <p>Strings only: (I always have forget this). Please note that both key and value must be strings, if not it will get converted automatically.</p>
        <ol>
            <li>localStorage.user = {name: "John"};</li>
            <li>alert(localStorage.user); // [object Object]</li>
        </ol>
        <p>JSON to store objects though:</p>
        <ol>
            <li>localStorage.user = JSON.stringify({name: "John"});</li>
            <li>let user = JSON.parse( localStorage.user );</li>
            <li>alert( user.name ); // John</li>
        </ol>
        <p><strong>sessionStorage</strong></p> 
        <p>The sessionStorage object is used much less often than localStorage. Properties and methods are the same, but it's much more limited:</p>

        <ul>
            <li>The sessionStorage exists only within the current browser tab.</li>
            <li>Another tab with the same page will have a different storage.</li>
            <li>But it is shared between iframes in the same tab (assuming they come from the same origin).</li>
            <li>The data survives page refresh, but not closing/opening the tab.</li>
        </ul>
        <p><strong>Storage event:</strong></p>
        <p>When the data gets updated in localStorage or sessionStorage, storage event triggers, with properties:</p>

        <ul>
            <li>key -> the key that was changed (null if .clear() is called).</li>
            <li>oldValue -> the old value (null if the key is newly added).</li>
            <li>newValue -> the new value (null if the key is removed).</li>
            <li>url -> the url of the document where the update happened.</li>
            <li>storageArea -> either localStorage or sessionStorage object where the update happened.</li>
        </ul>
        <h2>Export</h2>
        <p>For instance, here all exports are valid:</p>
        <pre>
        //export an array
        export let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov',
        'Dec'];
        
        //export a constant
        export const MODULES_BECAME_STANDARD_YEAR = 2015;
        
        //export a class
        export class User {
          constructor(name) {
            this.name = name;
           }
        }
        </pre>
        <p>Export apart from declarations:</p>
        <pre>
        // 📁 say.js
        function sayHi(user) {
           alert(`Hello, ${user}!`);
        }
        
        function sayBye(user) {
           alert(`Bye, ${user}!`);
        }
        
        export {sayHi, sayBye}; //list of exported variables
        </pre>

        <h2>Import</h2> 
        <p>
            Usually, we put a list of what to import in curly braces import {...}, like
            this:
        </p>
        <pre>
        // 📁 main.js
        import {sayHi, sayBye} from './say.js';
        
        sayHi('John'); // Hello, John!
        sayBye('John'); // Bye, John!
        </pre>
        <p>Import “as”: We can also use as to import under different names.</p>
        <pre>
        import {sayHi as hi, sayBye as bye} from './say.js';
        
        hi('John'); // Hello, John!
        bye('John'); // Bye, John!
        </pre>
        <p>Same syntax for export "as".</p>
        <p>Export default</p>
        <pre>
        // 📁 user.js
        export default class User { // just add "default"
          constructor(name) {
            this.name = name;
          }
        }
        </pre>
        <p>There may be only one export default per file.  
        …And then import it without curly braces:</p>
        <pre>
        // 📁 main.js
        import User from './user.js'; // not {User}, just User        
        new User('John');
        </pre>
        <p>Don't forget curly braces:</p>
        <table>
            <th>Named export</th>
            <th>Default export</th>
            <tr>
                <td>export class User {...}</td>
                <td>export default class User {...}</td>
            </tr>
            <tr>
                <td>import {User} from ...</td>
                <td>import User from ...</td>
            </tr>
        </table>
        
       

        <p><a href="task02.html">Chapter Tasks </a></p>
    </main>
    <footer>
         <p>&copy; <span id="date1"></span> | Camila Melo | WDD 330 | Last updated: <span id="date2"></span> | <a href="../index.html" class="portal">Portal</a></p>
    </footer>
    <script src="../script/date.js" defer></script> 
    <script src="ex02.js"></script> 
</body>

</html>